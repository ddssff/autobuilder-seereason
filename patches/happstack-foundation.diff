--- old/Happstack/Foundation.hs	2013-07-24 13:46:06.000000000 -0700
+++ new/Happstack/Foundation.hs	2013-07-25 06:16:37.649523988 -0700
@@ -27,8 +27,7 @@
 -}
 module Happstack.Foundation
     ( -- * Configuration
-      AcidConfig(..)
-    , FoundationConf(..)
+      FoundationConf(..)
     , defaultConf
       -- * Type Aliases
     , FoundationT
@@ -42,6 +41,8 @@
       -- * HTML Template
     , defaultTemplate
       -- * acid-state
+    , HasAcidState(..)
+    , AppState(acid)
     , query
     , update
       -- * running
@@ -96,6 +97,9 @@
 class HasAcidState m st where
     getAcidState :: m (AcidState st)
 
+instance HasAcidState m st => HasAcidState (XMLGenT m) st where
+    getAcidState = XMLGenT getAcidState
+
 -- | wrapper around query from acid-state
 --
 -- This variant automatically gets the 'AcidState' handle from the monad
@@ -126,29 +130,10 @@
     do as <- getAcidState
        update' (as :: AcidState (EventState event)) event
 
--- | bracket the opening and close of the `AcidState` handle.
---
--- automatically creates a checkpoint on close
---
--- unfortunately, when nesting multiple calls if some migrations
--- succeed and some fail it leaves the system in an state where it is
--- hard to roll back to the old version of the app because some of the
--- checkpoints have been upgrade. We should replace this with a
--- version that only does the checkpoint if *all* the acid states
--- could be openned successfully.
-withLocalState :: (MonadBaseControl IO m, MonadIO m, IsAcidic st, Typeable st) =>
-                  Maybe FilePath        -- ^ path to state directory
-               -> st                    -- ^ initial state value
-               -> (AcidState st -> m a) -- ^ function which uses the `AcidState` handle
-               -> m a
-withLocalState mPath initialState =
-    bracket (liftIO $ (maybe openLocalState openLocalStateFrom mPath) initialState)
-            (\acid -> liftIO $ (createArchive acid >> createCheckpointAndClose acid))
-
 -- | simple record that holds some state information that we want available in the 'FoundationT' monad
 data AppState url acidState requestState = AppState
     { here  :: url
-    , acid  :: AcidState acidState
+    , acid  :: acidState
     , reqSt :: requestState
     }
 
@@ -189,9 +174,6 @@
 
 modifyRequestState f = modify $ \appState -> appState { reqSt = f (reqSt appState) }
 
-instance (Functor m, Monad m) => HasAcidState (FoundationT url acidState requestState m) acidState where
-    getAcidState = acid <$> get
-
 -- | an error type used with reform forms
 data AppError
     = AppCFE (CommonFormError [Input])
@@ -211,13 +193,6 @@
 -- | 'FoundationForm' is an alias for working with reform based Forms
 type FoundationForm url acidState requestState m = Form (FoundationT url acidState requestState m) [Input] AppError [FoundationT url acidState requestState m XML] ()
 
--- | configuration information for our acid-state database
-data AcidConfig st
-    = AcidLocal
-      { acidPath      :: Maybe FilePath  -- ^ optional path for acid-state directory
-      , initialState  :: st              -- ^ initial state
-      }
-
 -- | default page template
 defaultTemplate :: ( Functor m, Monad m
                    , XMLGenerator (FoundationT' url acidState requestState m)
@@ -248,22 +223,21 @@
 -- | run the application
 --
 -- starts the database, listens for requests, etc.
-simpleApp :: (ToMessage a, IsAcidic acidState, Typeable acidState, PathInfo url, Monad m) =>
+simpleApp :: (ToMessage a, PathInfo url, Monad m) =>
              (forall r. m r -> IO r)             -- ^ function to flatten inner monad
           -> FoundationConf                      -- ^ 'Conf' to pass onto 'simpleHTTP'
-          -> AcidConfig acidState                -- ^ 'AcidState' configuration
+          -> acidState                           -- ^ 'AcidState' configuration
           -> requestState                        -- ^ initial @requestState@ value
           -> url                                 -- ^ default URL (ie, what does / map to)
           -> Text                                -- ^ the base URL for the site as seen by the outside world (or, at least, by your openid provider) (e.g. "http://example.org:8000", no trailing slash)
           -> (url -> FoundationT url acidState requestState m a) -- ^ handler
           -> IO ()
-simpleApp flattener FoundationConf{..} acidConfig initialReqSt defRoute baseURI route =
-    withLocalState (acidPath acidConfig) (initialState acidConfig) $ \acid ->
+simpleApp flattener FoundationConf{..} acid initialReqSt defRoute baseURI route =
         do tid <- forkIO $ simpleHTTP httpConf $ do decodeBody bodyPolicy
-                                                    implSite baseURI Text.empty (site acid)
+                                                    implSite baseURI Text.empty site
            waitForTermination
            killThread tid
     where
-      site acid =
+      site =
           setDefault defRoute $ mkSitePI (\showFn url ->
                                         mapServerPartT flattener (evalStateT (unRouteT (unXMLGenT (route url)) showFn) (AppState url acid initialReqSt)))
